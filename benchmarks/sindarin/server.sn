# ==============================================================================
# examples/json/server.sn - JSON REST API Server
# ==============================================================================
# A simple REST API that stores JSON objects in memory.
# Run: make examples-json-server
#
# Endpoints:
#   GET    /items      - List all items
#   POST   /items      - Create a new item
#   GET    /items/{id} - Get item by ID
#   PUT    /items/{id} - Update item by ID
#   DELETE /items/{id} - Delete item by ID
# ==============================================================================

import "../../src/server"

# In-memory storage for items
var items: Json

# Synchronization lock for thread-safe access to items and nextId
sync var itemsLock: int = 0

var nextId: int = 1

# Max items to store (prevent memory exhaustion during benchmarks)
var maxItems: int = 10000

# Extract ID from path like "/items/123"
fn extractId(path: str): int =>
    var parts: str[] = path.split("/")
    if parts.length >= 3 =>
        return parts[2].toInt()
    return -1

# Find item index by ID (caller must hold lock)
fn findItemIndexUnsafe(id: int): int =>
    var i: int = 0
    while i < items.length() =>
        var item: Json = items.getAt(i)
        var itemId: Json = item.get("id")
        var found: bool = itemId.asInt() == id
        # Removed dispose calls to test if they cause double-free
        # itemId.dispose()
        # item.dispose()
        if found =>
            return i
        i = i + 1
    return -1

# GET /items - List all items
fn listItems(req: HttpRequest): HttpResponse =>
    var resp: HttpResponse
    lock(itemsLock) =>
        resp = HttpResponse.ok().jsonPretty(items)
    return resp

# POST /items - Create a new item
fn createItem(req: HttpRequest): HttpResponse =>
    if !req.isJson() =>
        return HttpResponse.badRequest().json("{\"error\": \"Content-Type must be application/json\"}")

    var body: Json = req.json()
    var resp: HttpResponse

    lock(itemsLock) =>
        var idVal: Json = Json.ofInt(nextId)
        body.set("id", idVal)
        # idVal disposed when local arena is cleaned up
        nextId = nextId + 1

        # Limit items to prevent memory exhaustion during benchmarks
        if items.length() < maxItems =>
            items.append(body)

        resp = HttpResponse.created().jsonPretty(body)
        # body disposed when local arena is cleaned up

    return resp

# GET /items/{id} - Get item by ID
fn getItem(req: HttpRequest): HttpResponse =>
    var id: int = extractId(req.path)
    var resp: HttpResponse

    lock(itemsLock) =>
        var index: int = findItemIndexUnsafe(id)
        if index < 0 =>
            resp = HttpResponse.notFound().json("{\"error\": \"Item not found\"}")
        else =>
            var item: Json = items.getAt(index)
            resp = HttpResponse.ok().jsonPretty(item)
            # item disposed when local arena is cleaned up

    return resp

# PUT /items/{id} - Update item by ID
fn updateItem(req: HttpRequest): HttpResponse =>
    if !req.isJson() =>
        return HttpResponse.badRequest().json("{\"error\": \"Content-Type must be application/json\"}")

    var id: int = extractId(req.path)
    var body: Json = req.json()
    var resp: HttpResponse

    lock(itemsLock) =>
        var index: int = findItemIndexUnsafe(id)
        if index < 0 =>
            resp = HttpResponse.notFound().json("{\"error\": \"Item not found\"}")
        else =>
            var idVal: Json = Json.ofInt(id)
            body.set("id", idVal)
            # idVal disposed when local arena is cleaned up

            # Remove old item and insert updated one
            items.removeAt(index)
            items.insert(index, body)
            resp = HttpResponse.ok().jsonPretty(body)
            # body disposed when local arena is cleaned up

    return resp

# DELETE /items/{id} - Delete item by ID
fn deleteItem(req: HttpRequest): HttpResponse =>
    var id: int = extractId(req.path)
    var index: int = -1

    lock(itemsLock) =>
        index = findItemIndexUnsafe(id)
        if index >= 0 =>
            items.removeAt(index)

    if index < 0 =>
        return HttpResponse.notFound().json("{\"error\": \"Item not found\"}")

    return HttpResponse.ok().json("{\"deleted\": true}")

# Route handler for /items (collection)
fn handleItems(req: HttpRequest): HttpResponse =>
    return match req.method =>
        "GET" => listItems(req)
        "POST" => createItem(req)
        else => HttpResponse.new(405).text("Method not allowed")

# Route handler for /items/{id} (single item)
fn handleItem(req: HttpRequest): HttpResponse =>
    return match req.method =>
        "GET" => getItem(req)
        "PUT" => updateItem(req)
        "DELETE" => deleteItem(req)
        else => HttpResponse.new(405).text("Method not allowed")

fn main(): void =>
    # Initialize items storage
    items = Json.array()

    # Create router
    var router: Router = Router.new()
    router.all("/items", handleItems)
    router.all("/items/*", handleItem)

    # Create and start server
    var server: HttpServer = HttpServer.new(router)
    server.listen(8081)
